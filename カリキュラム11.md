# Unity11:namespace・usingと例外と列挙型

## namespace

C#にはnamespaceという概念があります。
日本語では名前空間と呼ばれます。
namespaceにはファイルスコープという概念の元カプセル化するための機能です。
また、同じ名前の複数のクラスを定義する場合などにも用いられます。

ではnamespaceはどのようなものなのかというと、クラスの本名です

カリキュラム1などで扱ったプログラムを例に出します。
「この部分」と記述している行がnamespaceの定義に当たります。

```cs
namespace ConsoleApp1; //この部分
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello World");
    }
}
```

`Program` というネームスペースは `ConsoleApp1` であるといえます。

今まで、`Program`クラスとして扱ってきましたが実際は`ConsoleApp1.Program`という名前のクラスになっています。

ほかにも
`Console`というクラスは`System`というnamespaceを持っているので
`System.Console`が本当の名前ということになります。

namespaceの書き方としては2種類あります。

```
namespace ネームスペース{

}
```

こちらの書き方では`{}`で囲まれたクラスを指定したネームスペースのクラスとして宣言します。

```
namespace ネームスペース;
```

こちらの書き方では次の行のクラスを指定したネームスペースのクラスとして宣言します。

複数の同じ名前を宣言できることはわかったと思います。

しかし、カプセル化の機能があると話しましたがどのようなことかというと通常クラス名だけを指定する状態であれば別のネームスペースからアクセスすることができないようになっています。

それを解決する方法としてはusingという機能になっています。
後に詳しく説明します。

### ネームスペースの階層構造

namespaceは`.`で区切ることでファイル構造のように表すことができます。
ファイルの場所を示す際は`\`や`/`でフォルダを区切って表現しますが、似た形でフォルダ構造をネームスペースで表現するということができます。


## using

usingは先ほど軽く説明しましたが、namespaceを省略することができるようにするための機能です

```cs
using ネームスペース名;
```
と入力すると入力されたnamespaceのクラスなどはnamespaceを省略して書くことができるようになります。

```cs
```

は`System`というネームスペースを読み込んでいることになります。


カプセル化に寄与するというのはusingを使用していない場合はネームスペースを含んだすべての名前を記述する必要があり間違えた呼び出しを防ぐことができるようになっています。

もし、エラーが出る場合はusingを追加してみてもいいかもしれません。


## 例外処理

例外処理はC#を実行している際に想定した動作や入力がない際にプログラムをすべて止める処理で、どのようなエラーが発生したか伝えることができます。

では実際に例外を起こしてみましょう

```cs
namespace ConsoleApp1; //この部分
class Program
{
    static void Main(string[] args)
    {
        int[] a = new int[10];

        a[10] = 1;
    }
}
```

このプログラムを実行すると

```
System.IndexOutOfRangeException: 'Index was outside the bounds of the array.'
```

とポップアップが表示される

これはインデックスの範囲外により`System.IndexOutOfRangeException`という例外が発生している。
長さが10の配列の場合0~9のインデックスになるので10であればこのようにエラーが発生する。

例外が発生することを例外が投げられるなどということもある。


ただし、このエラーがあったときにエラー用の処理をしたい場合があります。

### try-catch

先ほどエラー用の処理をしたい場合があります。と説明しましたが、その時にtry-catchというものを使用します。

実際に使い方を説明します。

先ほどのコードに以下のように記述します。


```cs
namespace ConsoleApp1; //この部分
class Program
{
    static void Main(string[] args)
    {
        int[] a = new int[10];
        try
        {
            a[10] = 1;
        }
        catch(IndexOutOfRangeException ex)
        {
            Console.WriteLine(ex.Message);
        }
        
    }
}
```

このようにすることによって例外が起きた場合にcatchの`{}`に移動し別の処理を行います。例外が発生した場所より後の処理は実行されません。



しかしこれはIndexOutOfRangeExceptionという例外が発生する場合のみキャッチされます。

すべての例外をキャッチしたい場合はすべての例外の基底クラスです。`Exception`クラスを指定することでその他エラーでもキャッチすることができますが、速度が低下する・意図しないエラーが発生した場合に気づかないという問題があるので極力使用を避けるべきです。

### finally

try-catchでエラーをキャッチすることができることが分かったと思いますが、エラーの有無にかかわらず処理の最後に絶対に実行する必要のある処理を行う必要がある場合は`finally{}`をtryもしくはcatchの後ろにつけることで`{}`内の処理を確実に実行するようにできます。

try-catchの後にfinallyを追加する方法
```cs
try
{
    //例外が発生する可能性のある処理
}
catch(Exception ex)
{
    //例外発生時の処理
}
finally{
   //例外の有無にかかわらず絶対に実行する処理 
}
```

tryの後にfinallyを追加する方法

```cs
try
{
    //例外が発生する可能性のある処理
}
finally{
   //例外の有無にかかわらず絶対に実行する処理 
}
```

このように記述することができます。


## 列挙型


C#には今の状態などを保持するために役立つ列挙型という要素があります。
intで数値を持っておきその数値によって処理を買えるといったことはできるが、それでは数値の意味を忘れてしまう可能性があります。その時に役立つのが列挙型という要素です。

列挙と名前が付くように状態を列挙するだけの型で関数や変数を持つことはできません。

列挙型はクラスや構造体と近い扱いで
新しいファイルを作って作成することが多い要素である。



実際に
TestEnum.csというファイルを作成し以下のように記述する。

```cs
enum TestEnum{

    Element1,
    Element2,
    Element3,
}

```

このようにenumと書いて宣言した中で要素名を書くことで使用することができます。

実際にTestEnum型を使用するには通常のクラスと同様以下のように変数として宣言します。

```cs
TestEnum te;
```

以上のように変数を宣言することができます。

値を代入する場合は
```
変数名 = 列挙型名.列挙型の要素
```

とすることが代入できstaticのメンバ変数に近い扱いを受けることがわかります。
TestEnumのElement1を代入する場合は以下の通りになります
```cs
te = TestEnum.Element1;
```

#### 列挙型の正体

列挙型は実はint型の定数を複数持ったクラスとほとんど同じ扱いです。
そのため、列挙型からint型、int型から列挙型に型を変換することが可能です



```
int n = (int)TestEnum.Element1;
Console.WriteLine(n);

n = (int)TestEnum.Element2;
Console.WriteLine(n);

n = (int)TestEnum.Element3;
Console.WriteLine(n);
```


以上のコードをMainメソッドに記述し実行すると以下のような実行結果になると思います

```
0
1
2
```

このように要素に上から順番に数値を打っていることがわかると思います。

このことから数値であることが確認できると思います。

この数値は自分で設定することも可能で
以下のように要素の右に代入する形で値を代入することで好きな数値に変えることが可能です。
```cs
enum TestEnum{

    Element1 = 1,
    Element2 = 2,
    Element3 = 4,
}

```
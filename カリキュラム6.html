<!DOCTYPE html>
<html>
<head>
<title>カリキュラム6.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="unity6%E5%8F%82%E7%85%A7%E5%9E%8B%E3%81%A8%E5%80%A4%E5%9E%8B%E3%81%AE%E9%81%95%E3%81%84%E3%83%BB%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AE%E9%81%95%E3%81%84">Unity6:参照型と値型の違い・クラスと構造体の違い</h1>
<h2 id="%E5%80%A4%E5%9E%8B%E3%81%A8%E5%8F%82%E7%85%A7%E5%9E%8B">値型と参照型</h2>
<p>C#には参照型と値型が存在しているその違いについて理解するために以下のプログラムを作成してみる。</p>
<p>DataTestClassというclassを作成する。
DataTestClass.csの中身は以下のように記述する。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataTestClass</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataTestClass</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
        {
            num = n;
        }
    }
}
</div></code></pre>
<p>Program.csの中身は以下のようにしてください。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>) <span class="hljs-comment">//Mainという関数作成する。</span></span>
    {
        DataTestClass dataTestClass1 = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">10</span>;
        
        DataTestClass dataTestClass2 = dataTestClass1;
        <span class="hljs-keyword">int</span> a2 = a1;

        a2 = <span class="hljs-number">20</span>;
        dataTestClass2.num = <span class="hljs-number">20</span>;

        Console.WriteLine(a1);
        Console.WriteLine(a2);

        Console.WriteLine(dataTestClass1.num);
        Console.WriteLine(dataTestClass2.num);        
    }
}
</div></code></pre>
<p>これを実行すると以下の結果になります。</p>
<pre class="hljs"><code><div>10
20
20
20

</div></code></pre>
<p>このように同じような処理をしているのに結果が変わってしまいます。
この理由が参照型にあります。
classなどの参照型の変数がオブジェクトがどこにあるかを記録しておくだけなので、データ本体はコピーされず、オブジェクトがどこにあるかの情報だけコピーすることになります。
感覚的にはHTMLファイルをそのままコピーするのではなくURLをコピーすることになります。
なので <code>dataTestClass1</code> の値を <code>dataTestClass2</code> にコピーしたつもりでも値をコピーしたのではなく参照をコピーしただけになるので参照先は同じで、同じ値を操作していることになります。
一方intでは値がコピーされるため<code>a2</code>を書き換えても<code>a1</code>の値は変わりません。</p>
<p>これが参照型と値型の大きな違いです。</p>
<p>なので代入する際は値型なのか参照型なのかしっかりと意識する必要があります。
また、参照型は実質的にコピーを作成することはできないと考えることができ、コピーしたい場合は含まれる値型要素になるまで遡ってコピーする必要があります。</p>
<p>また、メソッドの引数を参照型にしている場合は参照渡し、値型にしている場合は値渡しといいます。</p>
<p>参照型であるメリットとしてはコピーする際に無駄なコピーを作ることがないので容量を圧迫しないというメリットがあります。</p>
<h2 id="%E6%A7%8B%E9%80%A0%E4%BD%93">構造体</h2>
<p>クラスのように自分で作成することができる値型はないのかという疑問が発生すると思うが、C#には構造体という機能があり、この機能を使うことでクラスのように自分で宣言する値型を作成することが可能である。</p>
<p>構造体を作成する方法を説明する</p>
<p>初めにclassと同様でソリューションの上から2番目のプロジェクト名を右クリックし
<img src="./images/image5-1.png" alt="ソリューション欄"></p>
<p>その後
追加&gt;新しいファイル
をクリックします。
<img src="./images/image6-1.png" alt=""></p>
<p>すると画面が変わるので「空の構造体」を選択していることを確認してください
<img src="./images/image6-2.png" alt=""></p>
<p><code>名前:</code>の欄に構造体の名前を入力します。
今回は<code>DataTestStruct</code>という名前にします。</p>
<p><img src="./images/image6-3.png" alt=""></p>
<p>作成ボタンを押すと以下のような画面に切り替わります。</p>
<p><img src="./images/image6-4.png" alt=""></p>
<p>これで構造体を作成することができました。</p>
<p>コードは以下のようになっています。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> DataTestStruct
    {
    }
}
</div></code></pre>
<p>このコードの</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> DataTestStruct
{
}
</div></code></pre>
<p>の{}内にメンバ要素を書いていく形になります。</p>
<p>では実際に動作の違いについて確認していくために以下のコードを用意してください。</p>
<p><code>DataTestClass.cs</code>は先ほどのコードと同じで以下のように記述してください。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataTestClass</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataTestClass</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
        {
            num = n;
        }
    }
}
</div></code></pre>
<p><code>DataTestStruct.cs</code>は以下のように書き換えてください。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> DataTestStruct
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataTestStruct</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
        {
            num = n;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;
    }
}
</div></code></pre>
<p><code>Program.cs</code> は以下のように書き換えてください</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>) <span class="hljs-comment">//Mainという関数作成する。</span></span>
    {
        DataTestClass Class1 = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">10</span>);
        DataTestStruct Struct1 = <span class="hljs-keyword">new</span> DataTestStruct(<span class="hljs-number">10</span>);
        
        DataTestClass Class2 = Class1;
        DataTestStruct Struct2 = Struct1;

        Struct2.num = <span class="hljs-number">20</span>;
        Class2.num = <span class="hljs-number">20</span>;

        Console.WriteLine(Class1.num);
        Console.WriteLine(Class2.num);

        Console.WriteLine(Struct1.num);
        Console.WriteLine(Struct2.num);        
    }
}
</div></code></pre>
<p>実行結果は以下の通りになると思います。</p>
<pre class="hljs"><code><div>20
20
10
20

</div></code></pre>
<p>このように構造体であれば値をコピーして使うことができました。</p>
<h3 id="%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AF%E9%9D%9E%E6%8E%A8%E5%A5%A8">構造体は非推奨</h3>
<p>構造体は使う上でデメリットが多くあります。</p>
<p>大きなデメリットとしては代入するたびに新しい値ができてしまうので、メモリを圧迫してしまうという点です。</p>
<p>また、代入するたびに新しいインスタンスができてしまうので変更を加えたつもりが変更されていないといった不具合の原因になることがあります。
そのため使用する際はしっかりと注意する必要があります。</p>
<h3 id="%E6%A7%8B%E9%80%A0%E4%BD%93%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E9%9D%A2">構造体を使う場面</h3>
<p>構造体を使うときは以下のことを目安として使用するようにしましょう</p>
<ul>
<li>長い期間使用しない</li>
<li>メンバ要素がすべて構造体である</li>
<li>コピーを多く作成する必要がある</li>
<li>要素の書き換えがない</li>
</ul>
<p>このような条件を満たした際に構造体を使うとよいでしょう。
あくまで目安なのでこれを遵守する必要はありませんが、参考として考えてください</p>
<h1 id="outrefin">out,ref,in</h1>
<p>少し話の内容が変わり、メソッドでの参照渡しについて詳しく説明していきたいと思います。</p>
<p>通常参照型を引数とした場合参照先の情報をメソッドに渡しているので、その変数に入るインスタンスを変更しても呼び出し元の変数は変わりません。</p>
<p>実際にコードを作成し、動かして確認してみましょう</p>
<p>DataTestClass.csファイルは以下のように書き換えてください。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataTestClass</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataTestClass</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
        {
            num = n;
        }
    }
}
</div></code></pre>
<p>Program.cs</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>) <span class="hljs-comment">//Mainという関数作成する。</span></span>
    {
        DataTestClass dataTestClass = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">10</span>);      
        Console.WriteLine(dataTestClass.num);
        ChengeValue(dataTestClass.num);
        Console.WriteLine(dataTestClass.num);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChengeValue</span>(<span class="hljs-params">DataTestClass dataTest</span>)</span>
    {
        dataTest = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">20</span>);

    }
}
</div></code></pre>
<p>これを実行すると</p>
<pre class="hljs"><code><div>10
10

</div></code></pre>
<p>このように変数の中身自体は変わっていないことがわかります。
これは値の参照を引数として渡しているためです。</p>
<p>しかし、通常の場合ではこれでも問題はないですし、意図せず値を変えてしまうことが少ないので危険性も少ないのですが、戻り値のほかに値を2個以上返した場合は不便になってしまいます。</p>
<p>そのために使用されるのが<strong>out</strong>や<strong>ref</strong>というキーワードです。</p>
<p><strong>out</strong> と <strong>ref</strong> は変数自体の場所を渡すキーワードです。
このキーワードを使用することで、Mainで使用している変数の中身の値を書きかえるということができるようになります。</p>
<p>では先ほどのプログラムの<code>Program.cs</code>ファイルを以下のように買い換えます。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>) <span class="hljs-comment">//Mainという関数作成する。</span></span>
    {
        DataTestClass dataTestClass = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">10</span>);      
        Console.WriteLine(dataTestClass.num);
        ChengeValue(<span class="hljs-keyword">ref</span> dataTestClass);
        Console.WriteLine(dataTestClass.num);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChengeValue</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> DataTestClass dataTest</span>)</span>
    {
        dataTest = <span class="hljs-keyword">new</span> DataTestClass(<span class="hljs-number">20</span>);
    }
}
</div></code></pre>
<p>実行すると以下のような結果になります</p>
<pre class="hljs"><code><div>10
20

</div></code></pre>
<p>このようにMain内の変数を書き換えることができました。</p>
<p><strong>ref</strong> キーワードはメソッドを宣言する際に引数の型名の前に <strong>ref</strong> とつけて使います。
呼び出しの際は 変数名の前にスペースを空け <strong>ref</strong> と書く必要があります。</p>
<p><strong>out</strong> も同様の使い方で使用できます。</p>
<p>以下にrefと通常の引数の違いを示した図があります。</p>
<p><img src="./images/refの仕様.png" alt="refの説明"></p>
<p>すぐに理解できなくても大丈夫ですが、refを使うことで呼び出し元の変数の場所を渡します。そのためrefの変数を上書きしたときにはdataTestClassの参照先を書き換えることになります。
対してrefがない場合ハdataTestClassが参照している値の場所だけを取得しているのでdataTestに値を代入してもdataTestの中身が変わるだけになります。
これらの仕様については<strong>C言語のポインタ</strong>という機能を学ぶことで深く理解することができると思います。</p>
<p>現状ではrefやoutを使うことで別のメソッドから書き換えることができるということだけ理解できれば大丈夫です。</p>
<p>refとoutでは仕様に若干の違いがあります。</p>
<p>refは呼び出す前に変数に値を必ず入れなければいけません。
対してoutは呼び出す前に値を入れることは必須ではなく値を入れることもできるという仕様になっています。
また、outはメソッドが終わるまでに値を割り当てる必要がありますが、
一方でrefは値を割り当てることは必須ではありません。</p>
<p>簡単にまとめるとoutは結果を出力する際に使いやすく、refはあくまでも引数として値を渡しつつ、更新も可能なものということになります。</p>
<p>また、inというキーワードがあり、これは引数として値を入れておき受け取ったメソッドではその変数の中身を置き換えることができないようになっており、読み取りに特化した引数を作成したい時はこちらを利用するとよいでしょう。書き方はoutなどと同様になっています。</p>
<p>また、outは呼び出す前に値を割り当てることが必須ではないので以下のような書き方も可能です。</p>
<pre class="hljs"><code><div>関数名(out 型名 変数名);
</div></code></pre>
<p>この書き方で書くことでメソッド内で変数を宣言し、その結果を受け取り次の処理につなげるということができます。</p>
<h2 id="out%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89">outを使用した基本的なメソッド</h2>
<p>文字列から数値などに変換する際にカリキュラム3で使用した<code>Parse</code>メソッドを使用すると変換することができます。しかし、この命令だと数値に変換できない文字列が入力された場合にエラーが発生してしまいます。
そこで、<code>TryParse</code>メソッドを使用すると変換できるか調べつつ変換することができます。</p>
<p><code>TryParse</code>メソッドは</p>
<pre class="hljs"><code><div>bool型変数 = 変換したい型.TryParse(入力文字列,out 出力先変数);
</div></code></pre>
<p>や</p>
<pre class="hljs"><code><div>bool型変数 = 変換したい型.TryParse(入力文字列,out 変換したい型 出力先変数);
</div></code></pre>
<p>のように使うことができます。</p>
<p><code>TryParse</code>メソッドを使用した例を以下に示します。
(なおMainメソッド内に書いてあるものとします)</p>
<pre class="hljs"><code><div>Console.WriteLine(<span class="hljs-string">"整数を入力してください。"</span>)

<span class="hljs-keyword">string</span> input = Console.ReadLine();

<span class="hljs-keyword">if</span>(<span class="hljs-keyword">int</span>.TryParse(input,<span class="hljs-keyword">out</span> <span class="hljs-keyword">int</span> num))
{
    Console.WriteLine(num+<span class="hljs-string">"×"</span>+num+<span class="hljs-string">"="</span>+(num*num));
}
<span class="hljs-keyword">else</span>
{
    Console.WriteLine(input+<span class="hljs-string">"はintに変換できませんでした"</span>);
}
</div></code></pre>
<p><code>int.Parse</code>では入力された値の変換した値を戻り値として返していましたが、<code>int.Parse</code>では入力された文字列が数値に変換できたかの結果をbool型で返します。また、2つ目の引数を<code>out</code>にすることで変換した結果を返すことになっています。</p>
<p>戻り値としてbool型が仕様されている理由としては先ほどの例の通りif文などの中にそのまま入れることができるためだと考えれらます。</p>
<h2 id="%E7%B7%B4%E7%BF%92%E5%95%8F%E9%A1%8C">練習問題</h2>
<h4 id="1-%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%A8%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E9%81%95%E3%81%84%E3%82%92%E8%AA%AC%E6%98%8E%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84">1. 構造体とクラスの違いを説明してください。</h4>
<details><summary>解答例</summary>
<p>構造体はコピーするときに変数の中身がコピーされる、対してクラスは参照をコピーする
など</p>
</details>
<h4 id="2-out%E3%81%A8ref%E3%81%AE%E9%81%95%E3%81%84%E3%82%92%E8%AA%AC%E6%98%8E%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84">2. outとrefの違いを説明してください。</h4>
<details><summary>解答例</summary>
<p>outは呼び出し時に初期化が不要で、メソッド内で値を絶対に代入しないといけない
refは呼び出し時に初期化が必要で、メソッド内で値を絶対に代入することはできますが、必須ではない</p>
</details>
<h4 id="3-tryparse%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E6%96%87%E5%AD%97%E5%88%97%E3%81%8Cint%E3%81%AB%E5%A4%89%E6%8F%9B%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B%E3%82%92%E8%AA%BF%E3%81%B9%E5%A4%89%E6%8F%9B%E3%81%A7%E3%81%8D%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AF%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E6%95%B0%E5%80%A4%E3%81%AE2%E5%80%8D%E3%81%AE%E6%95%B0%E5%80%A4%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%97%E5%A4%89%E6%8F%9B%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%81%AF%E5%A4%89%E6%8F%9B%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%81%A7%E3%81%97%E3%81%9F%E3%81%A8%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84">3. TryParseメソッドを使用し入力された文字列がintに変換できるかを調べ、変換できた場合は入力された数値の2倍の数値を出力し、変換できない場合は「変換できませんでした」と出力するプログラムを作成してください。</h4>
<details><summary>解答例</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>) <span class="hljs-comment">//Mainという関数作成する。</span></span>
    {
        <span class="hljs-keyword">string</span> s;
        s = Console.WriteLine();
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">int</span>.TryParse(s,<span class="hljs-keyword">out</span> <span class="hljs-keyword">int</span> num))
        {
            Console.WriteLine(num+<span class="hljs-string">"の二倍は"</span>+(num * <span class="hljs-number">2</span>)+<span class="hljs-string">"です"</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            Console.WriteLine(<span class="hljs-string">"変換できませんでした"</span>);
        }
    }
}
</div></code></pre>
</details>

</body>
</html>
